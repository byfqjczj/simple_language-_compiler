- Write a fun program that runs in 10 seconds when using your fun interpreter
  from p2. Please don't commit it. Run the compiled version from p4, how long
  does it take to run?
i = 0
while(i<4500000)
{
    i=i+1
    print i
}
This is a fun program that takes 10 seconds for my fun interpreter to run.
This code takes around 2.5 seconds for my fun compiler to run.

- Why does compiled code run faster than interpreted code?
Compiled code runs faster than interpreted code as compiled code only needs to be executed at runtime.
While the interpreted code must be interpreted, converted into machine code, and then be executed, which adds significant overhead.

- Does your code run as fast as it could? What is slowing it down?
My code does not run as fast as it could. Numerous potential optimizations could be done such as constant folding and tail gate optimizations, and not implementing them slows my code down.

- What is emulator? Use your words and give examples
An emulator is a program that can imitate the functionality of other software or hardware systems. It provides an accurate simulation that will map the same output given the same input.
An example of an emulator would be P3, which emulates a set of arm commands. Another example of an emulator would be bluestacks, which lets you play mobile games on your computer.

- What is a cross-compiler? Use your words and give examples
A cross-compiler is a compiler that generates code for a platform that is different from the platform that actually runs the compiler.
An example of a cross-compiler would be arm compiler for the project, which is actually ran on a x86 system.

- What is a tool-chain? Use your words and give examples
A tool-chain is a set of "tools" such as compiler, assembler, and debugger that is combined together to perform complex tasks such as what we did in P4.
An example of the tool-chain would be the makefile and all its dependencies, which includes all the tools necessary for us to turn compile our .s code, run it, and then do all the comparisons.

- Why did I add the "argc" requirement in this assignment?
Argc is a way to stop students from "cheating" by doing all the calculations with the p2 interpreter, and then naively using the MOV command to get the interpreted result into the registers.
It prevents this sort of cheating, as you only get the value of argC after your C code cranks out the compiled code, which prevents you from recycling p2 code.
